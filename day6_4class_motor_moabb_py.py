# -*- coding: utf-8 -*-
"""day6_4class_motor_moabb.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AFIh5Qqr3kq_-g3FPzrR3-hhKwpwRoeh
"""

# MOABB-inspired 4-class motor imagery with CSP + SVM

import mne
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from pyriemann.estimation import Covariances
from pyriemann.classification import MDM

# Load GDF
raw = mne.io.read_raw_gdf('/content/A01T.gdf', preload=True)
events, event_dict = mne.events_from_annotations(raw)

# Preprocessing
raw.notch_filter(50, picks='eeg')
raw.filter(8, 30, fir_design='firwin', picks='eeg')
ica = mne.preprocessing.ICA(n_components=15, random_state=42)
ica.fit(raw)
raw = ica.apply(raw)

# Epoching
sfreq = 250
tmin, tmax = 1, 6  # Your 33% window
n_samples = int((tmax - tmin) * sfreq)
event_ids = {'769': 0, '770': 1, '771': 2, '772': 3}

X, y = [], []
for event in events:
    event_id = event[2]
    if event_id in [event_dict[str(k)] for k in event_ids]:
        start = event[0] - int(4 * sfreq)
        stop = start + n_samples
        if start >= 0 and stop <= raw.n_times:
            data, _ = raw[:, start:stop]
            X.append(data)
            y.append(event_ids[str([k for k, v in event_dict.items() if v == event_id][0])])

X = np.array(X)
y = np.array(y)
print(f"X shape: {X.shape}, y shape: {y.shape}")
print(f"Label counts: {np.unique(y, return_counts=True)}")

# Feature Extraction + MDM
cov = Covariances().fit_transform(X)
clf = MDM(metric='riemann')
X_train, X_test, y_train, y_test = train_test_split(cov, y, test_size=0.3, random_state=42)
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)
print(f"Test accuracy: {accuracy_score(y_test, y_pred):.2f}")

import mne
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from pyriemann.estimation import Covariances
from pyriemann.classification import MDM
from mne.decoding import CSP
from scipy.signal import welch
from scipy.signal import cwt, morlet
from sklearn.svm import SVC
from sklearn.pipeline import make_pipeline
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

#Loading the Raw EEG Data
raw = mne.io.read_raw_gdf('/content/A01T.gdf')
events, event_dict = mne.events_from_annotations(raw)

#Applying Filters (notch / bandpass)
raw.notch_filter(50, picks='eeg')
raw.filter(8, 30, fir_design='firwin', picks='eeg')

#ICA Fltering - Independent Component Analysis, Eye Blinks/Muscle Movements/etc.
ica = mne.preprocessing.ICA(n_components=15, random_state=42)
ica.fit(raw)
raw = ica.apply(raw)

#Averaging the signals from all electrodes
raw.set_eeg_reference('average', projection=True)
raw.apply_proj()

# #Automatic Epoching with mne
# tmin, tmax = 1, 6
# event_ids = {'769': 0, '770': 1, '771': 2, '772': 3}
# epochs = mne.Epochs(raw, events, event_ids=event_ids, tmin=tmin, tmax=tmax, baseline=None, preload=True)

#Manual Epoching
s_freq = 250
tmin, tmax = 1, 6
n_samples = int((tmax - tmin) * s_freq)
event_ids = {'769': 0, '770': 1, '771': 2, '772': 3}

X, y = [], []
for event in events:
    event_id = event[2]
    if event_id in [event_dict[str(k)] for k in event_ids]:
        start = event[0] - int(4 * s_freq)
        stop = start + n_samples
        if start >= 0 and stop <= raw.n_times:
            data, _ = raw[:, start:stop]
            X.append(data)
            y.append(event_ids[str([k for k, v in event_dict.items() if v == event_id][0])])
#Epochs
X = np.array(X)
#label
y = np.array(y)

print(f"X shape: {X.shape}, y shape: {y.shape}")
print(f"Label counts: {np.unique(y, return_counts=True)}")

#Feature Extraction Methods

# #1 - Common Spatial Patterns (CSP)
# csp = CSP(n_components=6)
# X_csp = csp.fit_transform(X, y)

# #2 - Power Spectral Density (PSD)
# freqs, psd = welch(X, fs=250, axis=-1)

# #3 - Wavelet Transform
# widths = np.arange(1, 31)
# features = np.array([cwt(channel, morlet, widths) for channel in X])

#4 - MDM - Minimum Distance Mean - Classifier (classifies the covariances - riemannian geometry)
#Calculating Covariances (spatial relationships between channels)
cov = Covariances().fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(cov, y, test_size=0.3, random_state=42)

clf = MDM(metric='riemann')
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)

# #SVM -Support Vector Machine - Classifier - 0.001
# #feature extraction using CSP (#1)
# csp = CSP(n_components=6)

# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
# pipeline = make_pipeline(csp, SVC(C=1, kernel='rbf', gamma='scale'))
# pipeline.fi(X_train, y_train)
# y_pred = pipeline.predict(X_test)

#Evaluation Metrics
#1 - Confusion Matrix
print(confusion_matrix(y_test, y_pred))

#2 - Classification Report
print(classification_report(y_test, y_pred))

#3 - Prints the final accuracy score
print(f"Test accuracy: {accuracy_score(y_test, y_pred):.2f}")

# raw.plot()

