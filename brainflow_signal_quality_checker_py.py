# -*- coding: utf-8 -*-
"""brainflow_signal_quality_checker.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gSEIOGhvkG3GKsjLESKWZL-XhNgdSOyQ
"""

!pip install --upgrade brainflow
!pip install PyWavelets

"""## **Simple Signal Quality Checker**
**Description**

This is a minimal working example of a signal quality checker designed for quick testing and debugging. It focuses on simplicity, avoiding advanced preprocessing steps like detrending or artifact removal. The script includes:

**Scaling** : Standardizes and scales the
signal to a realistic EEG range (-100 µV to +100 µV).

**Noise Addition** : Adds small Gaussian noise to simulate variability.

**Signal Quality Metric** : Uses variance as a simple proxy for signal quality.

**Key Features**

Easy to implement and debug.

Minimal dependencies on external libraries.

Suitable for beginners or users who need a quick signal quality check.

**Use Case**

Ideal for initial testing or educational purposes.

Works well with synthetic data but may not generalize to real-world EEG signals.
"""

import numpy as np
from brainflow.board_shim import BoardShim, BrainFlowInputParams
import time

# Release any existing board sessions
try:
    BoardShim.release_all_sessions()
except Exception as e:
    print(f"Error during cleanup: {e}")

# Setup board
board_id = -1  # Synthetic board
params = BrainFlowInputParams()

try:
    board = BoardShim(board_id, params)
    board.prepare_session()
    board.start_stream()

    # Wait for data to accumulate (simulate real-time delay)
    time.sleep(5)  # Wait longer for data to accumulate

    # Retrieve data
    data = board.get_board_data(250 * 5)  # 5 seconds of data (250 Hz sampling rate)

    # Check if data is valid
    if data.size == 0:
        raise ValueError("No data received from the board. Check the connection or buffer size.")

    # Get EEG channels and sampling rate
    eeg_channels = BoardShim.get_eeg_channels(board_id)
    sampling_rate = BoardShim.get_sampling_rate(board_id)

    # Debugging: Print data shape and content
    print(f"Data shape: {data.shape}")
    print(f"EEG channels: {eeg_channels}")
    print(f"Sampling rate: {sampling_rate}")

    # Process each EEG channel
    for ch in eeg_channels:
        signal = data[ch]  # Extract the signal for the current channel

        # Scale the signal to a realistic EEG range (-100 µV to +100 µV)
        signal = (signal - np.mean(signal)) / np.std(signal)  # Standardize
        signal *= 100  # Scale to ±100 µV

        # Add small Gaussian noise to simulate variability
        signal += np.random.normal(0, 1e-3, len(signal))

        # Calculate signal quality (using variance as a proxy)
        signal_variance = np.var(signal)
        print(f"Channel {ch}: Variance = {signal_variance:.2f}")

        # Check signal quality (arbitrary threshold)
        if signal_variance < 1.0:  # Arbitrary threshold
            print(f"Warning: Channel {ch} has low signal quality!")

    # Cleanup
    board.stop_stream()
    board.release_session()

except Exception as e:
    print(f"Error: {e}")

"""# **Enhanced Signal Quality Checker with Advanced Preprocessing**

**Description**

This is an enhanced version of the signal quality checker that incorporates advanced preprocessing techniques commonly used in EEG analysis pipelines. It includes:

**Filtering** :

Bandpass filter (0.5–50 Hz) to focus on the EEG frequency range.

Notch filter (e.g., 50 Hz) to remove powerline interference.

**Wavelet Denoising** : Removes noise while preserving signal details.

**Independent Component Analysis (ICA) **: Separates artifacts (e.g., eye blinks, muscle activity) from the EEG signal.

**Median Filtering** : Smooths out spikes and abrupt changes.

**Signal Quality Metric**s :
SNR (Signal-to-Noise Ratio): Provides a meaningful measure of signal quality.

**Artifact Detection**: Flags extreme amplitude values and sudden jumps.

**Key Features**

Detailed insights into signal quality using SNR and artifact detection.

Mimics real-world EEG preprocessing pipelines, making it more applicable to actual EEG data.

Includes visualization tools to inspect raw and filtered signals.

**Use Case**

Suitable for research or clinical applications requiring detailed signal quality metrics.

Can be integrated into advanced EEG analysis pipelines.
"""

import numpy as np
from brainflow.board_shim import BoardShim, BrainFlowInputParams
from scipy.signal import butter, filtfilt, medfilt
from sklearn.decomposition import FastICA
import pywt  # For wavelet denoising
import matplotlib.pyplot as plt
import time

# Release any existing board sessions
try:
    BoardShim.release_all_sessions()
except Exception as e:
    print(f"Error during cleanup: {e}")

# Setup board
board_id = -1  # Synthetic board
params = BrainFlowInputParams()

try:
    board = BoardShim(board_id, params)
    board.prepare_session()
    board.start_stream()

    # Wait for data to accumulate (simulate real-time delay)
    time.sleep(5)  # Wait longer for data to accumulate

    # Retrieve data
    data = board.get_board_data(250 * 5)  # 5 seconds of data (250 Hz sampling rate)

    # Check if data is valid
    if data.size == 0:
        raise ValueError("No data received from the board. Check the connection or buffer size.")

    # Get EEG channels and sampling rate
    eeg_channels = BoardShim.get_eeg_channels(board_id)
    sampling_rate = BoardShim.get_sampling_rate(board_id)

    # Debugging: Print data shape and content
    print(f"Data shape: {data.shape}")
    print(f"EEG channels: {eeg_channels}")
    print(f"Sampling rate: {sampling_rate}")

    # Define a Butterworth bandpass filter using SciPy
    def butter_bandpass_filter(signal, lowcut, highcut, fs, order=4):
        nyquist = 0.5 * fs  # Nyquist frequency
        low = lowcut / nyquist  # Normalize low cutoff frequency
        high = highcut / nyquist  # Normalize high cutoff frequency
        b, a = butter(order, [low, high], btype='band')  # Design the filter
        filtered_signal = filtfilt(b, a, signal)  # Apply the filter
        return filtered_signal

    # Define a notch filter using SciPy
    def notch_filter(signal, notch_freq, fs, quality_factor=30):
        nyquist = 0.5 * fs  # Nyquist frequency
        freq = notch_freq / nyquist  # Normalize notch frequency
        b, a = butter(2, [freq - freq / quality_factor, freq + freq / quality_factor], btype='bandstop')
        filtered_signal = filtfilt(b, a, signal)  # Apply the filter
        return filtered_signal

    # Define wavelet denoising
    def wavelet_denoising(signal, wavelet='db4', level=1):
        coeffs = pywt.wavedec(signal, wavelet, level=level)
        threshold = np.median(np.abs(coeffs[-1])) / 0.6745 * np.sqrt(2 * np.log(len(signal)))
        coeffs[1:] = [pywt.threshold(c, threshold, mode='soft') for c in coeffs[1:]]
        denoised_signal = pywt.waverec(coeffs, wavelet)
        return denoised_signal

    # Process each EEG channel
    for ch in eeg_channels:
        signal = data[ch]  # Extract the signal for the current channel

        # Scale the signal to a realistic EEG range (-100 µV to +100 µV)
        signal = (signal - np.mean(signal)) / np.std(signal)  # Standardize
        signal *= 100  # Scale to ±100 µV

        # Add small Gaussian noise to simulate variability
        signal += np.random.normal(0, 1e-3, len(signal))

        # Apply a Butterworth bandpass filter (0.5–50 Hz)
        try:
            signal = butter_bandpass_filter(signal, lowcut=0.5, highcut=50, fs=sampling_rate, order=4)
        except Exception as e:
            print(f"Error applying bandpass filter to Channel {ch}: {e}")
            continue

        # Apply a notch filter (e.g., 50 Hz for powerline interference)
        try:
            signal = notch_filter(signal, notch_freq=50, fs=sampling_rate)
        except Exception as e:
            print(f"Error applying notch filter to Channel {ch}: {e}")
            continue

        # Apply median filtering to smooth out spikes
        try:
            signal = medfilt(signal, kernel_size=3)  # Use a small kernel size for smoothing
        except Exception as e:
            print(f"Error applying median filter to Channel {ch}: {e}")
            continue

        # Apply wavelet denoising
        try:
            signal = wavelet_denoising(signal, wavelet='db4', level=1)
        except Exception as e:
            print(f"Error applying wavelet denoising to Channel {ch}: {e}")
            continue

        # Visualize raw vs filtered signals
        plt.figure(figsize=(10, 6))
        plt.plot(data[ch], label="Raw Signal", alpha=0.7)
        plt.plot(signal, label="Filtered Signal", alpha=0.7)
        plt.title(f"Channel {ch}: Raw vs Filtered Signal")
        plt.legend()
        plt.show()

        # Apply Independent Component Analysis (ICA) for artifact removal
        try:
            # Reshape the signal for ICA (requires 2D input)
            signal_reshaped = signal.reshape(-1, 1)
            ica = FastICA(n_components=1, random_state=42)
            ica.fit(signal_reshaped)
            cleaned_signal = ica.transform(signal_reshaped).flatten()
            signal = cleaned_signal  # Replace the signal with the cleaned version
        except Exception as e:
            print(f"Error applying ICA to Channel {ch}: {e}")
            continue

        # Calculate SNR (simple approximation)
        signal_variance = np.var(signal)
        noise_variance = np.var(np.diff(signal))  # Approximate noise using differences between samples
        if noise_variance == 0:
            snr = float('inf')  # Avoid division by zero
        else:
            snr = 10 * np.log10(signal_variance / noise_variance)
        print(f"Channel {ch}: SNR = {snr:.2f} dB")

        # Artifact detection (check for extreme values or sudden jumps)
        max_amplitude = np.max(np.abs(signal))
        sudden_jumps = np.any(np.abs(np.diff(signal)) > 100)  # Further relaxed threshold for sudden jumps (±100 µV)
        if max_amplitude > 300:  # Further relaxed threshold for extreme amplitude (±300 µV)
            print(f"Warning: Channel {ch} has extreme amplitude values (potential artifact).")
        if sudden_jumps:
            print(f"Warning: Channel {ch} has sudden jumps (potential artifact).")

        # Check signal quality (based on SNR)
        if snr < 10:  # Arbitrary threshold
            print(f"Warning: Channel {ch} has low signal quality!")

    # Cleanup
    board.stop_stream()
    board.release_session()

except Exception as e:
    print(f"Error: {e}")